<!-- Magnetic Field Hero Container -->
<div class="defcon-magnetic-hero">
  <!-- Particle Canvas -->
  <canvas class="defcon-magnetic-canvas"></canvas>
  
  <!-- Protected Content Zone -->
  <div class="defcon-magnetic-content">
    <h1 class="defcon-magnetic-title">Innovative Digital Solutions</h1>
    <p class="defcon-magnetic-subtitle">Harnessing cutting-edge technology to transform your business</p>
    <a href="#" class="defcon-magnetic-button">Explore Our Work</a>
  </div>
  
  <!-- Cursor Glow Element -->
  <div class="defcon-magnetic-cursor"></div>
</div>

<style>
/* Base Styles */
.defcon-magnetic-hero,
.defcon-magnetic-canvas,
.defcon-magnetic-content,
.defcon-magnetic-title,
.defcon-magnetic-subtitle,
.defcon-magnetic-button,
.defcon-magnetic-cursor {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Hero Container */
.defcon-magnetic-hero {
  position: relative;
  width: 100%;
  height: 100vh;
  min-height: 600px;
  background-color: #ffffff;
  overflow: hidden;
  font-family: "Times New Roman", Times, serif;
}

/* Canvas for Particles */
.defcon-magnetic-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

/* Protected Content Zone */
.defcon-magnetic-content {
  position: relative;
  z-index: 2;
  width: 80%;
  max-width: 1000px;
  margin: 0 auto;
  padding: 50px;
  text-align: center;
  background-color: rgba(200, 199, 199, 0.85);
  border-radius: 6px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
  transform: translateY(50%);
}

.defcon-magnetic-title {
  font-size: 3.5vw;
  font-weight: 700;
  color: #06273e;
  margin-bottom: 20px;
  line-height: 1.3;
}

.defcon-magnetic-subtitle {
  font-size: 1.5vw;
  color: #06273e;
  margin-bottom: 30px;
  opacity: 0.8;
  line-height: 1.5;
}

.defcon-magnetic-button {
  display: inline-block;
  padding: 15px 35px;
  background-color: #0091ff;
  color: #ffffff;
  font-size: 1.1vw;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
  box-shadow: 0 5px 15px rgba(0, 145, 255, 0.3);
}

.defcon-magnetic-button:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(0, 145, 255, 0.4);
}

/* Cursor Glow */
.defcon-magnetic-cursor {
  position: absolute;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0, 145, 255, 0.15) 0%, rgba(0, 145, 255, 0) 70%);
  pointer-events: none;
  z-index: 3;
  transform: translate(-50%, -50%);
  opacity: 0;
  transition: opacity 0.3s ease, width 0.3s ease, height 0.3s ease;
}

/* Responsive Styles */
@media (max-width: 1024px) {
  .defcon-magnetic-content {
    width: 90%;
    padding: 30px;
    transform: translateY(40%);
  }
  
  .defcon-magnetic-title {
    font-size: 5vw;
  }
  
  .defcon-magnetic-subtitle {
    font-size: 2.5vw;
  }
  
  .defcon-magnetic-button {
    font-size: 2vw;
    padding: 12px 30px;
  }
}

@media (max-width: 768px) {
  .defcon-magnetic-content {
    padding: 25px;
    transform: translateY(30%);
  }
  
  .defcon-magnetic-title {
    font-size: 7vw;
  }
  
  .defcon-magnetic-subtitle {
    font-size: 3.5vw;
  }
  
  .defcon-magnetic-button {
    font-size: 3vw;
    padding: 10px 25px;
  }
}

@media (max-width: 480px) {
  .defcon-magnetic-content {
    padding: 20px;
    transform: translateY(20%);
  }
  
  .defcon-magnetic-title {
    font-size: 9vw;
  }
  
  .defcon-magnetic-subtitle {
    font-size: 4.5vw;
    margin-bottom: 20px;
  }
  
  .defcon-magnetic-button {
    font-size: 4vw;
    padding: 8px 20px;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Canvas setup
  const canvas = document.querySelector('.defcon-magnetic-canvas');
  const ctx = canvas.getContext('2d');
  const cursor = document.querySelector('.defcon-magnetic-cursor');
  
  // Set canvas to full size
  function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
  }
  
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  
  // Mouse position
  let mouseX = canvas.width / 2;
  let mouseY = canvas.height / 2;
  let mouseDown = false;
  
  // Track mouse position
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    cursor.style.left = e.clientX + 'px';
    cursor.style.top = e.clientY + 'px';
    cursor.style.opacity = '1';
  });
  
  canvas.addEventListener('mouseleave', () => {
    cursor.style.opacity = '0';
  });
  
  canvas.addEventListener('mousedown', () => {
    mouseDown = true;
    cursor.style.width = '150px';
    cursor.style.height = '150px';
    createMagneticPulse(mouseX, mouseY);
  });
  
  canvas.addEventListener('mouseup', () => {
    mouseDown = false;
    cursor.style.width = '100px';
    cursor.style.height = '100px';
  });
  
  // Particle class
  class Particle {
    constructor() {
      this.reset();
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.baseX = this.x;
      this.baseY = this.y;
      this.vx = 0;
      this.vy = 0;
    }
    
    reset() {
      this.size = Math.random() * 5 + 1;
      this.shape = Math.floor(Math.random() * 3); // 0=circle, 1=triangle, 2=square
      this.color = `rgba(0, 145, 255, ${Math.random() * 0.5 + 0.1})`;
      this.mass = this.size * 0.2;
      this.resistance = Math.random() * 0.02 + 0.01;
      this.originalDistance = 0;
    }
    
    update() {
      // Calculate distance to mouse
      const dx = mouseX - this.x;
      const dy = mouseY - this.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Calculate distance to content area (protected zone)
      const content = document.querySelector('.defcon-magnetic-content');
      const contentRect = content.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      const contentCenterX = (contentRect.left + contentRect.width/2) - canvasRect.left;
      const contentCenterY = (contentRect.top + contentRect.height/2) - canvasRect.top;
      const contentRadius = Math.max(contentRect.width, contentRect.height) / 2;
      
      const contentDx = contentCenterX - this.x;
      const contentDy = contentCenterY - this.y;
      const contentDistance = Math.sqrt(contentDx * contentDx + contentDy * contentDy);
      
      // Mouse magnetic field
      if (distance < 300) {
        const forceDirectionX = dx / distance;
        const forceDirectionY = dy / distance;
        
        // Stronger force when closer
        const force = (300 - distance) / 300;
        const accelerationX = forceDirectionX * force * 0.1 / this.mass;
        const accelerationY = forceDirectionY * force * 0.1 / this.mass;
        
        this.vx += accelerationX;
        this.vy += accelerationY;
      }
      
      // Content protection field (repulsion)
      if (contentDistance < contentRadius + 50) {
        const forceDirectionX = contentDx / contentDistance;
        const forceDirectionY = contentDy / contentDistance;
        
        // Stronger repulsion when closer to content
        const force = (contentRadius + 50 - contentDistance) / (contentRadius + 50);
        const accelerationX = forceDirectionX * force * 0.2 / this.mass;
        const accelerationY = forceDirectionY * force * 0.2 / this.mass;
        
        this.vx -= accelerationX;
        this.vy -= accelerationY;
      }
      
      // Apply friction
      this.vx *= (1 - this.resistance);
      this.vy *= (1 - this.resistance);
      
      // Move particle
      this.x += this.vx;
      this.y += this.vy;
      
      // Keep particles within canvas
      if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
        this.reset();
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = 0;
        this.vy = 0;
      }
    }
    
    draw() {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      
      switch(this.shape) {
        case 0: // Circle
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          break;
        case 1: // Triangle
          ctx.moveTo(this.x, this.y - this.size);
          ctx.lineTo(this.x - this.size, this.y + this.size);
          ctx.lineTo(this.x + this.size, this.y + this.size);
          break;
        case 2: // Square
          ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
          break;
      }
      
      ctx.closePath();
      ctx.fill();
    }
  }
  
  // Create magnetic pulse effect
  function createMagneticPulse(x, y) {
    particles.forEach(particle => {
      const dx = particle.x - x;
      const dy = particle.y - y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 200) {
        const forceDirectionX = dx / distance;
        const forceDirectionY = dy / distance;
        const force = (200 - distance) / 200 * 5;
        
        particle.vx += forceDirectionX * force;
        particle.vy += forceDirectionY * force;
      }
    });
  }
  
  // Create particles
  const particles = [];
  const particleCount = window.innerWidth < 768 ? 100 : 300;
  
  for (let i = 0; i < particleCount; i++) {
    particles.push(new Particle());
  }
  
  // Animation loop
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw magnetic field lines near cursor
    if (cursor.style.opacity === '1') {
      const nearbyParticles = particles.filter(p => {
        const dx = mouseX - p.x;
        const dy = mouseY - p.y;
        return Math.sqrt(dx * dx + dy * dy) < 150;
      });
      
      // Adjust cursor glow based on nearby particles
      const glowIntensity = Math.min(nearbyParticles.length / 10, 1);
      cursor.style.background = `radial-gradient(circle, rgba(0, 145, 255, ${0.1 + glowIntensity * 0.1}) 0%, rgba(0, 145, 255, 0) 70%)`;
      
      // Draw field lines
      ctx.strokeStyle = `rgba(0, 145, 255, ${0.2 + glowIntensity * 0.3})`;
      ctx.lineWidth = 1;
      
      nearbyParticles.forEach(p => {
        ctx.beginPath();
        ctx.moveTo(mouseX, mouseY);
        
        // Create curved path
        const cp1x = mouseX + (p.x - mouseX) * 0.3;
        const cp1y = mouseY + (p.y - mouseY) * 0.3;
        const cp2x = mouseX + (p.x - mouseX) * 0.6;
        const cp2y = mouseY + (p.y - mouseY) * 0.6;
        
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
        ctx.stroke();
      });
    }
    
    // Update and draw particles
    particles.forEach(particle => {
      particle.update();
      particle.draw();
    });
    
    requestAnimationFrame(animate);
  }
  
  animate();
});
</script>