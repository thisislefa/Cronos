<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Constellation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow-x: hidden;
      background: #0a0a12;
      color: white;
      font-family: 'Inter', sans-serif;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1;
    }

    .content {
      position: relative;
      z-index: 2;
      min-height: 200vh;
      padding: 100px 20px;
    }

    .grid-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background-image: 
        linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 3;
    }

    .section-title {
      font-size: 3rem;
      margin-bottom: 40px;
      background: linear-gradient(90deg, #00f2fe, #ff00ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-align: center;
    }

    .scroll-hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 4;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    @media (max-width: 768px) {
      .section-title {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="grid-overlay"></div>
  
  <div class="content">
    <h1 class="section-title">Interactive Constellation Network</h1>
  </div>
  
  <div class="scroll-hint">
    <span>Scroll to explore</span>
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M7 13l5 5 5-5M7 6l5 5 5-5"/>
    </svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/gh/mrdoob/three.js@r128/examples/js/lines/LineMaterial.js"></script>
  <script src="https://cdnjs.cloudflare.com/gh/mrdoob/three.js@r128/examples/js/lines/LineGeometry.js"></script>
  <script src="https://cdnjs.cloudflare.com/gh/mrdoob/three.js@r128/examples/js/lines/Line2.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.8.0/gsap.min.js"></script>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize Three.js scene
      const container = document.getElementById('canvas-container');
      let mouseX = 0;
      let mouseY = 0;
      let windowHalfX = window.innerWidth / 2;
      let windowHalfY = window.innerHeight / 2;
      let scrollY = 0;
      
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 15;
      
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);
      
      // Create nodes and connections
      const nodes = [];
      const connections = [];
      const nodeCount = 30;
      const maxConnections = 3;
      
      // Colors
      const colors = {
        cyan: new THREE.Color(0x00f2fe),
        pink: new THREE.Color(0xff00ff),
        white: new THREE.Color(0xffffff)
      };
      
      // Create nodes
      for (let i = 0; i < nodeCount; i++) {
        const geometry = new THREE.SphereGeometry(0.2, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
          color: i % 2 === 0 ? colors.cyan : colors.pink,
          transparent: true,
          opacity: 0.8
        });
        
        const node = new THREE.Mesh(geometry, material);
        
        // Position nodes in a spherical formation
        const radius = 5 + Math.random() * 5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        node.position.x = radius * Math.sin(phi) * Math.cos(theta);
        node.position.y = radius * Math.sin(phi) * Math.sin(theta);
        node.position.z = radius * Math.cos(phi);
        
        node.userData = {
          originalX: node.position.x,
          originalY: node.position.y,
          originalZ: node.position.z,
          speed: 0.2 + Math.random() * 0.3,
          pulseSpeed: 0.5 + Math.random(),
          size: 0.2 + Math.random() * 0.3,
          connections: []
        };
        
        scene.add(node);
        nodes.push(node);
      }
      
      // Create floating geometric shapes
      const shapes = [];
      const shapeTypes = [
        () => new THREE.IcosahedronGeometry(1, 0),
        () => new THREE.DodecahedronGeometry(1, 0),
        () => new THREE.OctahedronGeometry(1, 0),
        () => new THREE.TorusKnotGeometry(0.8, 0.3, 100, 16)
      ];
      
      for (let i = 0; i < 8; i++) {
        const type = shapeTypes[i % shapeTypes.length];
        const geometry = type();
        const material = new THREE.MeshBasicMaterial({
          color: Math.random() > 0.5 ? colors.cyan : colors.pink,
          wireframe: true,
          transparent: true,
          opacity: 0.3
        });
        
        const shape = new THREE.Mesh(geometry, material);
        
        // Position shapes randomly
        shape.position.x = (Math.random() - 0.5) * 20;
        shape.position.y = (Math.random() - 0.5) * 20;
        shape.position.z = (Math.random() - 0.5) * 20;
        
        shape.userData = {
          rotationSpeed: {
            x: Math.random() * 0.01,
            y: Math.random() * 0.01,
            z: Math.random() * 0.01
          }
        };
        
        scene.add(shape);
        shapes.push(shape);
      }
      
      // Create connections between nodes
      function createConnections() {
        // Clear existing connections
        connections.forEach(connection => scene.remove(connection));
        connections.length = 0;
        
        // Reset node connections
        nodes.forEach(node => node.userData.connections = []);
        
        // Create new connections
        nodes.forEach((node, i) => {
          // Find closest nodes
          const closestNodes = nodes
            .map((otherNode, j) => ({ node: otherNode, index: j, distance: node.position.distanceTo(otherNode.position) }))
            .filter(item => item.index !== i)
            .sort((a, b) => a.distance - b.distance)
            .slice(0, maxConnections);
          
          closestNodes.forEach(closest => {
            // Check if connection already exists
            if (!node.userData.connections.includes(closest.index) && !closest.node.userData.connections.includes(i)) {
              node.userData.connections.push(closest.index);
              
              // Create line geometry
              const points = [
                new THREE.Vector3(node.position.x, node.position.y, node.position.z),
                new THREE.Vector3(closest.node.position.x, closest.node.position.y, closest.node.position.z)
              ];
              
              const geometry = new THREE.BufferGeometry().setFromPoints(points);
              const material = new THREE.LineBasicMaterial({
                color: colors.white,
                transparent: true,
                opacity: 0.3,
                linewidth: 1
              });
              
              const line = new THREE.Line(geometry, material);
              scene.add(line);
              connections.push(line);
            }
          });
        });
      }
      
      // Create glowing connections
      function createGlowingConnections(fromNode, toNodes) {
        toNodes.forEach(node => {
          const positions = [
            fromNode.position.x, fromNode.position.y, fromNode.position.z,
            node.position.x, node.position.y, node.position.z
          ];
          
          const geometry = new LineGeometry();
          geometry.setPositions(positions);
          
          const material = new LineMaterial({
            color: 0xffffff,
            linewidth: 0.005,
            transparent: true,
            opacity: 0.8,
            dashed: false,
            alphaToCoverage: true
          });
          
          const line = new Line2(geometry, material);
          line.computeLineDistances();
          scene.add(line);
          connections.push(line);
        });
      }
      
      // Mouse movement
      document.addEventListener('mousemove', (e) => {
        mouseX = (e.clientX - windowHalfX) / 100;
        mouseY = (e.clientY - windowHalfY) / 100;
        
        // Find closest node to mouse
        const mouseVector = new THREE.Vector3(
          (e.clientX / window.innerWidth) * 2 - 1,
          -(e.clientY / window.innerHeight) * 2 + 1,
          0.5
        );
        
        mouseVector.unproject(camera);
        mouseVector.sub(camera.position).normalize();
        
        const raycaster = new THREE.Raycaster(camera.position, mouseVector);
        const intersects = raycaster.intersectObjects(nodes);
        
        if (intersects.length > 0) {
          const closestNode = intersects[0].object;
          
          // Highlight connected nodes
          const connectedNodes = closestNode.userData.connections.map(index => nodes[index]);
          
          // Remove all connections
          connections.forEach(connection => scene.remove(connection));
          connections.length = 0;
          
          // Create glowing connections to connected nodes
          createGlowingConnections(closestNode, connectedNodes);
          
          // Create connections between connected nodes
          connectedNodes.forEach(node => {
            const nodeConnections = node.userData.connections
              .map(index => nodes[index])
              .filter(n => n !== closestNode);
            
            createGlowingConnections(node, nodeConnections);
          });
        } else {
          // Recreate original connections when not hovering
          createConnections();
        }
      });
      
      // Scroll interaction
      window.addEventListener('scroll', () => {
        scrollY = window.scrollY / (document.body.scrollHeight - window.innerHeight);
        
        // Adjust node positions based on scroll
        nodes.forEach((node, i) => {
          const scrollFactor = scrollY * 2;
          const angle = (i / nodeCount) * Math.PI * 2 + scrollFactor * Math.PI;
          
          node.position.x = node.userData.originalX * (1 + scrollFactor * 0.5);
          node.position.y = node.userData.originalY * (1 + scrollFactor * 0.5);
          node.position.z = node.userData.originalZ + Math.sin(angle) * 5 * scrollFactor;
        });
        
        // Recreate connections with new positions
        createConnections();
      });
      
      // Animation loop
      const clock = new THREE.Clock();
      
      function animate() {
        requestAnimationFrame(animate);
        
        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();
        
        // Animate nodes
        nodes.forEach(node => {
          // Pulsing effect
          const pulse = Math.sin(elapsedTime * node.userData.pulseSpeed) * 0.1 + 1;
          node.scale.setScalar(node.userData.size * pulse);
          
          // Slow floating movement
          node.position.x += Math.sin(elapsedTime * node.userData.speed) * 0.01;
          node.position.y += Math.cos(elapsedTime * node.userData.speed * 0.7) * 0.01;
          node.position.z += Math.sin(elapsedTime * node.userData.speed * 0.5) * 0.01;
        });
        
        // Animate shapes
        shapes.forEach(shape => {
          shape.rotation.x += shape.userData.rotationSpeed.x;
          shape.rotation.y += shape.userData.rotationSpeed.y;
          shape.rotation.z += shape.userData.rotationSpeed.z;
        });
        
        // Parallax effect on camera
        camera.position.x += (mouseX * 0.5 - camera.position.x) * 0.05;
        camera.position.y += (-mouseY * 0.5 - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        renderer.render(scene, camera);
      }
      
      // Handle resize
      window.addEventListener('resize', () => {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Initial connections
      createConnections();
      
      // Start animation
      animate();
    });
  </script>
</body>
</html>